package models

// 求 a 的 n 次方
// a、n 是非负整数
func Pow(a, n int64) int64 {
	// 0 的任何次方都是 0
	if a == 0 {
		return 0
	}

	// 任何数的 0 次方都是 1
	if n == 0 {
		return 1
	}

	// 1 次方是它自身
	if n == 1 {
		return a
	}

	// 用滚雪球的方式计算幂
	// 雪球初始值是 1
	var result int64 = 1
	// 滚动因子初始化为 a 的 1 次方（a 自身）
	factor := a
	// 循环处理直到 n 变成 0（所有的二进制位都处理完了）
	for n != 0 {
		// 跟 1 做与运算，判断当前要处理的位是不是 1
		// 之所以是直接跟 1 做与运算，因为后面每处理一轮都将 n 右移了一位，保证每次要处理的位都在最低位
		if n&1 != 0 {
			// 当前位是 1，需要乘进去
			result *= factor
		}
		// 每轮结束时将滚动因子自乘
		// 因为每行进一轮，指数都翻倍，整体结果就是自乘
		// 比如本轮因子是 2**4，下一轮就是 2**8
		// 2**8 = 2**(4+4) = 2**4 * 2**4
		// （** 表示指数）
		factor *= factor
		// n 右移一位，将下一轮要处理的位放在最低位
		n = n >> 1
	}

	return result
}
